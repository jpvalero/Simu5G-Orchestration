[General]
image-path=../../../images
output-scalar-file-append = false
**.routingRecorder.enabled = false

############### Statistics ##################
output-scalar-file = ${resultdir}/${configname}/${iterationvars}-${repetition}.sca
output-vector-file = ${resultdir}/${configname}/${iterationvars}-${repetition}.vec
seed-set = ${repetition}
num-rngs = 3
**.sctp.**.scalar-recording = false  # remove annoying statistics from SCTP
**.sctp.**.vector-recording = false  # remove annoying statistics from SCTP
**.cbr**.vector-recording = true


############### SCTP configuration ##################
**.sctp.nagleEnabled = false         # if true, transmission of small packets will be delayed on the X2
**.sctp.enableHeartbeats = false

############### General PHY parameters ##############
**.downlink_interference = true
**.uplink_interference = true
**.ueTxPower = 26
**.eNodeBTxPower = 46
**.targetBler = 0.01
**.blerShift = 5  
**.fbPeriod = 40   # reports CQI every 40ms

############### IPv4 configurator config #################
*.configurator.config = xmldoc("./demo.xml")

############# Floorplan parameters ################
**.mobility.constraintAreaMaxX = 1000m
**.mobility.constraintAreaMaxY = 750m
**.mobility.constraintAreaMinX = 0m
**.mobility.constraintAreaMinY = 0m
**.mobility.constraintAreaMinZ = 0m
**.mobility.constraintAreaMaxZ = 0m
**.mobility.initFromDisplayString = false

*.playgroundSizeX = 1100m
*.playgroundSizeY = 800m
*.playgroundSizeZ = 0m





#===============================================================
[Config SingleMec]
network = simu5g.simulations.NR.mec.singleMecHost.singleMecHost

#######################################################
#        CA and channel model configuration           # 
#######################################################
*.carrierAggregation.numComponentCarriers = 1
*.carrierAggregation.componentCarrier[0].numBands =  25 #${numBands=25}

*.*.cellularNic.LteChannelModelType = "NRChannelModel"
*.gNodeB1.cellularNic.numCarriers = 1
*.gNodeB1.cellularNic.channelModel[0].componentCarrierIndex = 0
*.ue[*].cellularNic.numCarriers = 1
*.ue[*].cellularNic.nrChannelModel[0].componentCarrierIndex = 0


##########################################################
#                      Mobility                          #			
##########################################################		
**.mobility.constraintAreaMinZ = 0m
**.mobility.constraintAreaMaxZ = 0m

*.ue[*].mobility.initFromDisplayString = false
*.ue[*].mobility.typename = "StationaryMobility"
#*.ue[*].mobility.updateInterval = 0.05s

*.gNodeB1.mobility.initFromDisplayString = true

**.numUes = 1
**.ue[0].mobility.initialX = 180m
**.ue[0].mobility.initialY = 50m
**.ue[0].mobility.initialMovementHeading = 90deg
**.ue[0].mobility.speed = 10mps

**.ue[1].mobility.initialX = 180m
**.ue[1].mobility.initialY = 100m
**.ue[1].mobility.initialMovementHeading = 90deg
**.ue[1].mobility.speed = 10mps

**.ue[2].mobility.initialX = 180m
**.ue[2].mobility.initialY = 150m
**.ue[2].mobility.initialMovementHeading = 90deg
**.ue[2].mobility.speed = 10mps

**.ue[*].masterId = 0    
**.ue[*].macCellId = 0   
**.ue[*].nrMasterId = 1
**.ue[*].nrMacCellId = 1
**.gNodeB1.macCellId = 1
**.gNodeB1.macNodeId = 1

# tcp settings
**.tcp.typename = "Tcp"
**.tcp.advertisedWindow = 65535         # in bytes, corresponds with the maximal receiver buffer capacity (Note: normally, NIC queues should be at least this size)
**.tcp.tcpAlgorithmClass = "TcpReno"    # TcpReno/TcpTahoe/TcpNewReno/TcpNoCongestionControl/DumbTcp
**.tcp.sackSupport = true               # Selective Acknowledgment (RFC 2018, 2883, 3517) support (header option) (SACK will be enabled for a connection if both endpoints support it)

**.hasRNISupport = true
##########################################################
#                    App Layer                           #
##########################################################
*.ue[*].numApps = 1
**.numIndependentMecApp = 1

*.ue[*].app[*].typename = "CbrRequester" 
*.ue[*].app[*].PacketSize = 1000      # send 800 Kb/s 
*.ue[*].app[*].sampling_time = 0.01s 
*.ue[*].app[*].localPort = 1000
*.ue[*].app[*].destAddress = "mecHost.virtualisationInfrastructure"
*.ue[*].app[*].destPort = 3000+ancestorIndex(1)   
*.ue[*].app[*].startTime = 0.05s

*.mecHost.independentMecApp[*].typename = "CbrResponder"   
*.mecHost.independentMecApp[*].PacketSize = 1000 
*.mecHost.independentMecApp[*].destAddress = "ue["+string(ancestorIndex(0))+"]" # obtain the address of the client by reading its index in the array of Apps 
*.mecHost.independentMecApp[*].destPort = 1000  
*.mecHost.independentMecApp[*].localPort = 3000+ancestorIndex(0)  
*.mecHost.independentMecApp[*].startTime = uniform(0.01s,0.05s) 
#----------------------------------------

######################_ME Host Side_#####################
# resources available
*.mecHost.maxMECApps = 100												#max ME Apps to instantiate
*.mecHost.maxRam = 32GB													#max KBytes of Ram Space 
*.mecHost.maxDisk = 100TB												#max KBytes of Ram Space 
*.mecHost.maxCpuSpeed = 400000											#max percentage of CPU
#----------------------------------------

*.gNodeB*.mecHost = "mecHost"
*.mecHost.bsList = "gNodeB1"
*.mecHost.mecPlatformManager.mecOrchestrator = "mecOrchestrator"

#------- MEC orchestrator---------------
**.mecOrchestrator.mecHostList = "mecHost"


#------------------------------------#
# Config MultiMec
#
# General configuration for the for a multicell, multi-MEC system
# In this scenario, the MEC orchestrator instantiates three MEC apps on 
# MEC Host 1 (because it has more CPU resources that MEC host 2. However,
# the MEC apps use the Location Service available on MEC Host 2 only.
#
[Config MultiMec]
sim-time-limit=40s
network = simu5g.simulations.NR.mec.Demo1GM.MultiMecHostGM

############### CA configuration ################# 
*.carrierAggregation.numComponentCarriers = 1
*.carrierAggregation.componentCarrier[0].numerologyIndex = ${u=0}
*.carrierAggregation.componentCarrier[0].carrierFrequency = 2GHz
*.carrierAggregation.componentCarrier[0].numBands = ${numRbs=50}

*.gnb*.cellularNic.numCarriers = 1
*.gnb*.cellularNic.channelModel[0].componentCarrierIndex = 0
*.ue[*].cellularNic.numCarriers = 1
*.ue[*].cellularNic.nrChannelModel[0].componentCarrierIndex = 0

############### BS position #################
*.gnb1.mobility.initialX = 250m
*.gnb1.mobility.initialY = 500m
*.gnb2.mobility.initialX = 750m
*.gnb2.mobility.initialY = 500m

############### X2 configuration #################
*.gnb*.numX2Apps = 1                                        # one x2App per peering node
*.gnb*.x2App[*].server.localPort = 5000 + ancestorIndex(1)  # Server ports (x2App[0]=5000, x2App[1]=5001, ...)
*.gnb1.x2App[0].client.connectAddress = "gnb2%x2ppp0" 
*.gnb2.x2App[0].client.connectAddress = "gnb1%x2ppp0" 

############## UE configuration ##################
*.numUe = ${numUEs=1}

# UEs associates to the best BS at the beginning of the simulation
*.ue[*].macCellId = 0
*.ue[*].masterId = 0
*.ue[*].nrMacCellId = 1
*.ue[*].nrMasterId = 1

**.gnb1.macCellId = 1
**.gnb1.macNodeId = 1

**.gnb2.macCellId = 2
**.gnb2.macNodeId = 2

**.dynamicCellAssociation = true
**.enableHandover = true

############ UEs position #################
*.ue[*].mobility.typename = "LinearMobility"

*.ue[*].mobility.constraintAreaMaxX = 800m
*.ue[*].mobility.constraintAreaMinX = 200m

*.ue[0].mobility.initialX = 201m
*.ue[1].mobility.initialX = 875m
*.ue[2].mobility.initialX = 950m
*.ue[*].mobility.initialY = 600m
*.ue[*].mobility.speed = 50mps#13.89mps
*.ue[*].mobility.initialMovementHeading = 0deg

############# App configuration ################
*.ue[*].numApps = 1
*.mecHost1.numIndependentMecApp = 1
*.mecHost1.virtualisationInfrastructure.numIndependentMecApp = 1

*.ue[*].app[*].typename = "CbrRequester" 
*.ue[*].app[*].PacketSize = 100      # send 800 Kb/s 
*.ue[*].app[*].sampling_time = 0.01s 
*.ue[*].app[*].localPort = 1000
*.ue[*].app[*].destAddress = "mecHost1.virtualisationInfrastructure"
*.ue[*].app[*].destPort = 3000+ancestorIndex(1)   
*.ue[*].app[*].startTime = 0.05s

*.mecHost1.independentMecApp[*].typename = "CbrResponder"   
*.mecHost1.independentMecApp[*].PacketSize = 1000 
*.mecHost1.independentMecApp[*].destAddress = "ue["+string(ancestorIndex(0))+"]" # obtain the address of the client by reading its index in the array of Apps 
*.mecHost1.independentMecApp[*].destPort = 1000  
*.mecHost1.independentMecApp[*].localPort = 3000+ancestorIndex(0)  
*.mecHost1.independentMecApp[*].startTime = uniform(0.01s,0.05s) 


############ MEC Configuration ############
**.hasRNISupport = true

# tcp settings
**.tcp.typename = "Tcp"
**.tcp.advertisedWindow = 65535         # in bytes, corresponds with the maximal receiver buffer capacity (Note: normally, NIC queues should be at least this size)
**.tcp.tcpAlgorithmClass = "TcpReno"    # TcpReno/TcpTahoe/TcpNewReno/TcpNoCongestionControl/DumbTcp
**.tcp.sackSupport = true               # Selective Acknowledgment (RFC 2018, 2883, 3517) support (header option) (SACK will be enabled for a connection if both endpoints support it)

# MEC Hosts
**.mecHost*.virtualisationInfrastructure.ipv4.forwarding = true
*.mecHost*.maxMECApps = 100					# max ME Apps to instantiate
*.mecHost*.maxRam = 32GB					# max KBytes of Ram 
*.mecHost*.maxDisk = 100TB					# max KBytes of Disk Space 
*.mecHost1.maxCpuSpeed = 400000		    	# max CPU
*.mecHost2.maxCpuSpeed = 500				# max CPU

*.mecHost*.bsList = "gnb1, gnb2"


# MEC Orchestrator configuration
*.mecOrchestrator.mecHostList = "mecHost1, mecHost2"              # MEC hosts associated to the MEC system
*.mecOrchestrator.mecHostIndex = 1
*.mecHost*.mecPlatformManager.mecOrchestrator = "mecOrchestrator" # the MECPM needs to know the MEC orchestrator


